# Lab 6 Report

计64 高天宇 2016011348

## 练习0：填写已有实验

略

## 练习1：Round Robin 调度算法

### sched_class各个函数指针的用法，以及ucore调度执行过程

schec_class各个函数指针的用法：

- `init`: 初始化调度器
- `enqueue`: 把进程放到调度队列当中去
- `dequee`: 从调度队列中移除某个进程
- `pick_next`: 选择下一个要运行的进程
- `proc_tick`: 对时钟中断的响应，在这里更新进程的相关信息

在`do_exit`, `do_wait`, `init_main`, `cpu_idle`, `lock`和`trap`中，会调用进程调度函数，其中

- `do_exit`, `do_wait`, `lock`中调用是因为某种资源得不到满足、进程退出、进程睡眠等原因，主动放弃了CPU使用权
- `init_main`等待用户进程结束而调用调度函数
- `cpu_idle`只在没有runnable的进程时才执行，一旦有runnable的进程则调度切换到其他进程执行

而在`trap`当中：

```c
if (!in_kernel) {
    ……

    if (current->need_resched) {
        schedule();
    }
}
```

由这段代码可以看出来，如果之前是在用户态，且这个进程的`need_resched`为true，就调用`schedule`。即当一个用户态进程因为某种原因发生了中断进入内核态，才会开始调度。进入内核态的时候该进程的trapframe已经保存好了，如何`need_resched`，调用`schedule`，使用`enqueue`加入当前进程，使用`pick_next`和`dequeue`选出下一个要占用CPU的进程，调用`proc_run`函数，再调用`switch_to`函数切换到下一个进程的内核态，再通过iret返回到用户态。对于RR算法来说，每次时钟中断的时候还要通过`proc_tick`来维护进程的相关信息（`time_slice`减1），当减完了之后就要把其设置为`need_resched`。
