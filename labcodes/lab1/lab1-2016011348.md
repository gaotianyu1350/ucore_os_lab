# Lab 1 Report

计64 高天宇 2016011348

## 练习1：理解通过make生成执行文件的过程

### 1. 操作系统镜像文件ucore.img是如何一步一步生成的

Makefile中生成`core.img`的代码如下，

```
$(UCOREIMG): $(kernel) $(bootblock)
	$(V)dd if=/dev/zero of=$@ count=10000
	$(V)dd if=$(bootblock) of=$@ conv=notrunc
	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
```

其依赖`kernel`和`bootblock`

生成`kernel`代码如下，

```
$(kernel): tools/kernel.ld

$(kernel): $(KOBJS)
	@echo + ld $@
	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)
	@$(OBJDUMP) -S $@ > $(call asmfile,kernel)
	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel)
```

其依赖`kernel.ld`和`init.o readline.o stdio.o kdebug.o kmonitor.o panic.o clock.o console.o intr.o picirq.o trap.o trapentry.o vectors.o pmm.o printfmt.o string.o`

`kernel.ld`已经存在，生成其他object文件代码如下，

```
$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS))
```

其中`add_files_cc`是定义的函数，指将传入的文件使用`$(CC)`指定的编译器编译，最后实际的编译指令举例如下

```
i386-elf-gcc -Ikern/init/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/ driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o
```

最终生成`kernel`的实际指令为

```
i386-elf-ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o
```

生成bootblock的代码如下

```
$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)
	@echo + ld $@
	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)
	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)
```

其依赖`bootasm.o bootmain.o`（由`$(bootfiles)`指定）和`sign`（由`sign`指定）

`bootasm.o bootmain.o`生成代码如下

```
bootfiles = $(call listf_cc,boot)
$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))
```

实际代码如下

```
i386-elf-gcc -Iboot/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o
i386-elf-gcc -Iboot/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o
```

生成`sign`代码如下

```
$(call add_files_host,tools/sign.c,sign,sign)
$(call create_target_host,sign,sign)
```

实际指令如下

```
gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o
gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign
```

然后生成`bootblock`，实际指令如下

```
i386-elf-ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o
```

其中参数的含义为

* `-m elf_i386`：模拟为i386上的连接器
* `-nostdlib`：不使用标准库
* `-N`：代码段和数据段均可读写
* `-e start`：代码入口
* `-Ttext 0x7c00`：代码段开始位置

后面两个指令分别表示拷贝`bootblock.o`到`bootblock.out`，以及使用`sign`处理`bootblock.out`，生成`botblock`

```
$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
$(call totarget,sign) $(call outfile,bootblock) $(bootblock)
```

其中参数有

* `-S` 移除所有符号和重定位信息
* `-O binary` 输出格式为二进制

至此我们已经得到了`kernel`和`bootblock`，开始执行下面的指令

```
$(V)dd if=/dev/zero of=$@ count=10000
```
这一句生成一个有`10000`个块的文件，每一块的默认大小512字节，用0填充

```
$(V)dd if=$(bootblock) of=$@ conv=notrunc
```
把`bootblock`写入第一个块

```
$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
```
从第二个块开始写入`kernel`

至此，`ucore`生成完毕

### 2. 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么

一个符合规范的硬盘主引导扇区特征是，512字节，且510个字节(从0开始编号)为0x55，511个字节是0xAA
